CCS PCM C Compiler, Version 5.008, 5967               11-jul-16 00:57

               Filename:   C:\Users\Bellini\Documents\Projetos PIC\ControleAcesso\source.lst

               ROM used:   783 words (10%)
                           Largest free fragment is 2048
               RAM used:   25 (7%) at main() level
                           39 (11%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  02
0001:  MOVWF  0A
0002:  GOTO   292
0003:  NOP
.................... #include <16F876.h> 
.................... //////// Standard Header file for the PIC16F876 device //////////////// 
.................... #device PIC16F876 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  28
0009:  RETLW  0C
000A:  RETLW  01
000B:  RETLW  06
000C:  BCF    0A.0
000D:  BCF    0A.1
000E:  BCF    0A.2
000F:  ADDWF  02,F
0010:  RETLW  31
0011:  RETLW  32
0012:  RETLW  33
0013:  RETLW  34
0014:  RETLW  35
0015:  RETLW  36
0016:  RETLW  37
0017:  RETLW  38
0018:  RETLW  39
0019:  RETLW  2A
001A:  RETLW  30
001B:  RETLW  23
001C:  DATA 0C,22
001D:  DATA E9,33
001E:  DATA 69,3A
001F:  DATA 65,10
0020:  DATA 61,10
0021:  DATA F4,32
0022:  DATA 63,36
0023:  DATA 61,10
0024:  DATA 31,05
0025:  DATA 00,00
0026:  DATA 0C,22
0027:  DATA E9,33
0028:  DATA 69,3A
0029:  DATA 65,10
002A:  DATA 61,10
002B:  DATA F4,32
002C:  DATA 63,36
002D:  DATA 61,10
002E:  DATA A5,3A
002F:  DATA 0A,00
0030:  DATA 0C,28
0031:  DATA 6F,39
0032:  DATA F4,30
0033:  DATA A0,30
0034:  DATA E2,32
0035:  DATA 72,3A
0036:  DATA E1,10
0037:  DATA 00,01
0038:  DATA 8C,29
0039:  DATA 65,37
003A:  DATA E8,30
003B:  DATA A0,32
003C:  DATA 72,39
003D:  DATA 61,32
003E:  DATA E1,10
003F:  DATA 00,00
*
011B:  MOVF   0B,W
011C:  MOVWF  32
011D:  BCF    0B.7
011E:  BSF    03.5
011F:  BSF    03.6
0120:  BSF    0C.7
0121:  BSF    0C.0
0122:  NOP
0123:  NOP
0124:  BCF    03.5
0125:  MOVF   0C,W
0126:  ANDLW  7F
0127:  BTFSC  03.2
0128:  GOTO   162
0129:  BCF    03.6
012A:  MOVWF  33
012B:  BSF    03.6
012C:  MOVF   0D,W
012D:  BCF    03.6
012E:  MOVWF  34
012F:  BSF    03.6
0130:  MOVF   0F,W
0131:  BCF    03.6
0132:  MOVWF  35
0133:  MOVF   33,W
0134:  MOVWF  38
0135:  CALL   0EF
0136:  MOVF   34,W
0137:  BSF    03.6
0138:  MOVWF  0D
0139:  BCF    03.6
013A:  MOVF   35,W
013B:  BSF    03.6
013C:  MOVWF  0F
013D:  BSF    03.5
013E:  BSF    0C.7
013F:  BSF    0C.0
0140:  NOP
0141:  NOP
0142:  BCF    03.5
0143:  RLF    0C,W
0144:  RLF    0E,W
0145:  ANDLW  7F
0146:  BTFSC  03.2
0147:  GOTO   162
0148:  BCF    03.6
0149:  MOVWF  33
014A:  BSF    03.6
014B:  MOVF   0D,W
014C:  BCF    03.6
014D:  MOVWF  34
014E:  BSF    03.6
014F:  MOVF   0F,W
0150:  BCF    03.6
0151:  MOVWF  35
0152:  MOVF   33,W
0153:  MOVWF  38
0154:  CALL   0EF
0155:  MOVF   34,W
0156:  BSF    03.6
0157:  MOVWF  0D
0158:  BCF    03.6
0159:  MOVF   35,W
015A:  BSF    03.6
015B:  MOVWF  0F
015C:  INCF   0D,F
015D:  BTFSC  03.2
015E:  INCF   0F,F
015F:  BCF    03.6
0160:  GOTO   11E
0161:  BSF    03.6
0162:  BCF    03.6
0163:  BTFSC  32.7
0164:  BSF    0B.7
0165:  RETURN
*
01B6:  CLRF   77
01B7:  CLRF   78
01B8:  MOVF   34,W
01B9:  BCF    03.0
01BA:  BTFSC  35.0
01BB:  ADDWF  77,F
01BC:  RRF    77,F
01BD:  RRF    78,F
01BE:  BTFSC  35.1
01BF:  ADDWF  77,F
01C0:  RRF    77,F
01C1:  RRF    78,F
01C2:  BTFSC  35.2
01C3:  ADDWF  77,F
01C4:  RRF    77,F
01C5:  RRF    78,F
01C6:  BTFSC  35.3
01C7:  ADDWF  77,F
01C8:  RRF    77,F
01C9:  RRF    78,F
01CA:  BTFSC  35.4
01CB:  ADDWF  77,F
01CC:  RRF    77,F
01CD:  RRF    78,F
01CE:  BTFSC  35.5
01CF:  ADDWF  77,F
01D0:  RRF    77,F
01D1:  RRF    78,F
01D2:  BTFSC  35.6
01D3:  ADDWF  77,F
01D4:  RRF    77,F
01D5:  RRF    78,F
01D6:  BTFSC  35.7
01D7:  ADDWF  77,F
01D8:  RRF    77,F
01D9:  RRF    78,F
*
01F0:  MOVF   0B,W
01F1:  MOVWF  34
01F2:  BCF    0B.7
01F3:  BSF    03.5
01F4:  BSF    03.6
01F5:  BSF    0C.7
01F6:  BSF    0C.0
01F7:  NOP
01F8:  NOP
01F9:  BTFSC  03.0
01FA:  GOTO   222
01FB:  BCF    03.5
01FC:  MOVF   0C,W
01FD:  ANDLW  7F
01FE:  BCF    03.6
01FF:  MOVWF  35
0200:  BSF    03.6
0201:  MOVF   0D,W
0202:  BCF    03.6
0203:  MOVWF  36
0204:  BSF    03.6
0205:  MOVF   0F,W
0206:  BCF    03.6
0207:  MOVWF  37
0208:  MOVF   35,W
0209:  MOVWF  38
020A:  CALL   0EF
020B:  MOVF   36,W
020C:  BSF    03.6
020D:  MOVWF  0D
020E:  BCF    03.6
020F:  MOVF   37,W
0210:  BSF    03.6
0211:  MOVWF  0F
0212:  BSF    03.5
0213:  BSF    0C.7
0214:  BSF    0C.0
0215:  NOP
0216:  NOP
0217:  BCF    03.5
0218:  BCF    03.6
0219:  DECFSZ 33,F
021A:  GOTO   21C
021B:  GOTO   21F
021C:  BSF    03.5
021D:  BSF    03.6
021E:  GOTO   222
021F:  GOTO   241
0220:  BSF    03.5
0221:  BSF    03.6
0222:  BCF    03.5
0223:  RLF    0C,W
0224:  RLF    0E,W
0225:  ANDLW  7F
0226:  BCF    03.6
0227:  MOVWF  35
0228:  BSF    03.6
0229:  MOVF   0D,W
022A:  BCF    03.6
022B:  MOVWF  36
022C:  BSF    03.6
022D:  MOVF   0F,W
022E:  BCF    03.6
022F:  MOVWF  37
0230:  MOVF   35,W
0231:  MOVWF  38
0232:  CALL   0EF
0233:  MOVF   36,W
0234:  BSF    03.6
0235:  MOVWF  0D
0236:  BCF    03.6
0237:  MOVF   37,W
0238:  BSF    03.6
0239:  MOVWF  0F
023A:  INCF   0D,F
023B:  BTFSC  03.2
023C:  INCF   0F,F
023D:  BCF    03.0
023E:  BCF    03.6
023F:  DECFSZ 33,F
0240:  GOTO   1F3
0241:  BTFSC  34.7
0242:  BSF    0B.7
0243:  BCF    0A.3
0244:  BCF    0A.4
0245:  GOTO   2D3 (RETURN)
0246:  MOVF   36,W
0247:  CLRF   78
0248:  SUBWF  35,W
0249:  BTFSC  03.0
024A:  GOTO   24E
024B:  MOVF   35,W
024C:  MOVWF  77
024D:  GOTO   25A
024E:  CLRF   77
024F:  MOVLW  08
0250:  MOVWF  37
0251:  RLF    35,F
0252:  RLF    77,F
0253:  MOVF   36,W
0254:  SUBWF  77,W
0255:  BTFSC  03.0
0256:  MOVWF  77
0257:  RLF    78,F
0258:  DECFSZ 37,F
0259:  GOTO   251
025A:  RETURN
025B:  MOVF   78,W
025C:  MOVF   33,W
025D:  MOVWF  35
025E:  MOVLW  64
025F:  MOVWF  36
0260:  CALL   246
0261:  MOVF   77,W
0262:  MOVWF  33
0263:  MOVF   78,W
0264:  MOVLW  30
0265:  BTFSS  03.2
0266:  GOTO   26E
0267:  BTFSS  34.1
0268:  GOTO   275
0269:  BTFSC  34.3
026A:  GOTO   275
026B:  BTFSC  34.4
026C:  MOVLW  20
026D:  GOTO   271
026E:  BCF    34.3
026F:  BCF    34.4
0270:  BSF    34.0
0271:  ADDWF  78,F
0272:  MOVF   78,W
0273:  MOVWF  38
0274:  CALL   0EF
0275:  MOVF   33,W
0276:  MOVWF  35
0277:  MOVLW  0A
0278:  MOVWF  36
0279:  CALL   246
027A:  MOVF   77,W
027B:  MOVWF  33
027C:  MOVF   78,W
027D:  MOVLW  30
027E:  BTFSS  03.2
027F:  GOTO   286
0280:  BTFSC  34.3
0281:  GOTO   28A
0282:  BTFSS  34.0
0283:  GOTO   28A
0284:  BTFSC  34.4
0285:  MOVLW  20
0286:  ADDWF  78,F
0287:  MOVF   78,W
0288:  MOVWF  38
0289:  CALL   0EF
028A:  MOVLW  30
028B:  ADDWF  33,F
028C:  MOVF   33,W
028D:  MOVWF  38
028E:  CALL   0EF
028F:  BCF    0A.3
0290:  BCF    0A.4
0291:  GOTO   2D8 (RETURN)
....................  
.................... #list 
....................  
.................... #fuses XT, NOWDT, NOPROTECT, NOLVP 
.................... #use delay(clock = 4000000) 
*
0040:  MOVLW  39
0041:  MOVWF  04
0042:  BCF    03.7
0043:  MOVF   00,W
0044:  BTFSC  03.2
0045:  GOTO   054
0046:  MOVLW  01
0047:  MOVWF  78
0048:  CLRF   77
0049:  DECFSZ 77,F
004A:  GOTO   049
004B:  DECFSZ 78,F
004C:  GOTO   048
004D:  MOVLW  4A
004E:  MOVWF  77
004F:  DECFSZ 77,F
0050:  GOTO   04F
0051:  GOTO   052
0052:  DECFSZ 00,F
0053:  GOTO   046
0054:  RETURN
.................... #use standard_io(a) 
....................  
.................... #define use_portb_kbd TRUE 
.................... #define use_portb_lcd TRUE 
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
006D:  MOVLW  0F
006E:  BSF    03.5
006F:  ANDWF  06,W
0070:  IORLW  F0
0071:  MOVWF  06
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0072:  BCF    03.5
0073:  BSF    06.2
....................    delay_cycles(1); 
0074:  NOP
....................    lcd_output_enable(1); 
0075:  BSF    06.0
....................    delay_cycles(1); 
0076:  NOP
....................    high = lcd_read_nibble(); 
0077:  CALL   061
0078:  MOVF   78,W
0079:  MOVWF  40
....................        
....................    lcd_output_enable(0); 
007A:  BCF    06.0
....................    delay_cycles(1); 
007B:  NOP
....................    lcd_output_enable(1); 
007C:  BSF    06.0
....................    delay_us(1); 
007D:  NOP
....................    low = lcd_read_nibble(); 
007E:  CALL   061
007F:  MOVF   78,W
0080:  MOVWF  3F
....................        
....................    lcd_output_enable(0); 
0081:  BCF    06.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0082:  MOVLW  0F
0083:  BSF    03.5
0084:  ANDWF  06,W
0085:  MOVWF  06
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0086:  BCF    03.5
0087:  SWAPF  40,W
0088:  MOVWF  77
0089:  MOVLW  F0
008A:  ANDWF  77,F
008B:  MOVF   77,W
008C:  IORWF  3F,W
008D:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
0061:  MOVF   06,W
0062:  MOVWF  77
0063:  SWAPF  06,W
0064:  ANDLW  0F
0065:  MOVWF  78
....................   #endif 
0066:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
0055:  SWAPF  40,W
0056:  ANDLW  F0
0057:  MOVWF  77
0058:  MOVLW  0F
0059:  ANDWF  06,W
005A:  IORWF  77,W
005B:  MOVWF  06
....................   #endif 
....................        
....................    delay_cycles(1); 
005C:  NOP
....................    lcd_output_enable(1); 
005D:  BSF    06.0
....................    delay_us(2); 
005E:  GOTO   05F
....................    lcd_output_enable(0); 
005F:  BCF    06.0
0060:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0067:  BSF    03.5
0068:  BCF    06.0
....................    lcd_rs_tris(); 
0069:  BCF    06.1
....................    lcd_rw_tris(); 
006A:  BCF    06.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
006B:  BCF    03.5
006C:  BCF    06.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
008E:  MOVF   78,W
008F:  MOVWF  3F
0090:  BTFSC  3F.7
0091:  GOTO   06D
....................    lcd_output_rs(address); 
0092:  BTFSS  3D.0
0093:  BCF    06.1
0094:  BTFSC  3D.0
0095:  BSF    06.1
....................    delay_cycles(1); 
0096:  NOP
....................    lcd_output_rw(0); 
0097:  BCF    06.2
....................    delay_cycles(1); 
0098:  NOP
....................    lcd_output_enable(0); 
0099:  BCF    06.0
....................    lcd_send_nibble(n >> 4); 
009A:  SWAPF  3E,W
009B:  MOVWF  3F
009C:  MOVLW  0F
009D:  ANDWF  3F,F
009E:  MOVF   3F,W
009F:  MOVWF  40
00A0:  CALL   055
....................    lcd_send_nibble(n & 0xf); 
00A1:  MOVF   3E,W
00A2:  ANDLW  0F
00A3:  MOVWF  3F
00A4:  MOVWF  40
00A5:  CALL   055
00A6:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00A7:  MOVLW  0F
00A8:  BSF    03.5
00A9:  ANDWF  06,W
00AA:  MOVWF  06
....................   #endif 
....................    lcd_enable_tris(); 
00AB:  BCF    06.0
....................    lcd_rs_tris(); 
00AC:  BCF    06.1
....................    lcd_rw_tris(); 
00AD:  BCF    06.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
00AE:  BCF    03.5
00AF:  BCF    06.1
....................    lcd_output_rw(0); 
00B0:  BCF    06.2
....................    lcd_output_enable(0); 
00B1:  BCF    06.0
....................      
....................    delay_ms(15); 
00B2:  MOVLW  0F
00B3:  MOVWF  39
00B4:  CALL   040
....................    for(i=1;i<=3;++i) 
00B5:  MOVLW  01
00B6:  MOVWF  32
00B7:  MOVF   32,W
00B8:  SUBLW  03
00B9:  BTFSS  03.0
00BA:  GOTO   0C3
....................    { 
....................        lcd_send_nibble(3); 
00BB:  MOVLW  03
00BC:  MOVWF  40
00BD:  CALL   055
....................        delay_ms(5); 
00BE:  MOVLW  05
00BF:  MOVWF  39
00C0:  CALL   040
00C1:  INCF   32,F
00C2:  GOTO   0B7
....................    } 
....................     
....................    lcd_send_nibble(2); 
00C3:  MOVLW  02
00C4:  MOVWF  40
00C5:  CALL   055
....................    delay_ms(5); 
00C6:  MOVLW  05
00C7:  MOVWF  39
00C8:  CALL   040
....................    for(i=0;i<=3;++i) 
00C9:  CLRF   32
00CA:  MOVF   32,W
00CB:  SUBLW  03
00CC:  BTFSS  03.0
00CD:  GOTO   0D7
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
00CE:  MOVF   32,W
00CF:  CALL   004
00D0:  MOVWF  33
00D1:  CLRF   3D
00D2:  MOVF   33,W
00D3:  MOVWF  3E
00D4:  CALL   067
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00D5:  INCF   32,F
00D6:  GOTO   0CA
00D7:  BCF    0A.3
00D8:  BCF    0A.4
00D9:  GOTO   2A9 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
00DD:  DECFSZ 3A,W
00DE:  GOTO   0E0
00DF:  GOTO   0E3
....................       address=LCD_LINE_TWO; 
00E0:  MOVLW  40
00E1:  MOVWF  3B
00E2:  GOTO   0E4
....................    else 
....................       address=0; 
00E3:  CLRF   3B
....................       
....................    address+=x-1; 
00E4:  MOVLW  01
00E5:  SUBWF  39,W
00E6:  ADDWF  3B,F
....................    lcd_send_byte(0,0x80|address); 
00E7:  MOVF   3B,W
00E8:  IORLW  80
00E9:  MOVWF  3C
00EA:  CLRF   3D
00EB:  MOVF   3C,W
00EC:  MOVWF  3E
00ED:  CALL   067
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
00EE:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
00EF:  MOVF   38,W
00F0:  XORLW  07
00F1:  BTFSC  03.2
00F2:  GOTO   0FD
00F3:  XORLW  0B
00F4:  BTFSC  03.2
00F5:  GOTO   102
00F6:  XORLW  06
00F7:  BTFSC  03.2
00F8:  GOTO   10A
00F9:  XORLW  02
00FA:  BTFSC  03.2
00FB:  GOTO   110
00FC:  GOTO   115
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
00FD:  MOVLW  01
00FE:  MOVWF  39
00FF:  MOVWF  3A
0100:  CALL   0DD
0101:  GOTO   11A
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0102:  CLRF   3D
0103:  MOVLW  01
0104:  MOVWF  3E
0105:  CALL   067
....................                      delay_ms(2); 
0106:  MOVLW  02
0107:  MOVWF  39
0108:  CALL   040
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0109:  GOTO   11A
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
010A:  MOVLW  01
010B:  MOVWF  39
010C:  MOVLW  02
010D:  MOVWF  3A
010E:  CALL   0DD
010F:  GOTO   11A
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0110:  CLRF   3D
0111:  MOVLW  10
0112:  MOVWF  3E
0113:  CALL   067
0114:  GOTO   11A
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0115:  MOVLW  01
0116:  MOVWF  3D
0117:  MOVF   38,W
0118:  MOVWF  3E
0119:  CALL   067
....................      #endif 
....................    } 
011A:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include <kbd.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             KBD.C                                 //// 
.................... ////                  Generic keypad scan driver                       //// 
.................... ////                                                                   //// 
.................... ////  kbd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  c = kbd_getc(c)  Will return a key value if pressed or /0 if not //// 
.................... ////                   This function should be called frequently so as //// 
.................... ////                   not to miss a key press.                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////// The following defines the keypad layout on port D 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_kbd TRUE 
....................  
.................... // Make sure the port used has pull-up resistors (or the LCD) on 
.................... // the column pins 
....................  
.................... #if defined use_portb_kbd 
....................    #byte kbd = getenv("SFR:PORTB") 
.................... #else 
....................    #byte kbd = getenv("SFR:PORTD") 
.................... #endif 
....................  
.................... #if defined use_portb_kbd 
....................    #define set_tris_kbd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_kbd(x) set_tris_d(x) 
.................... #endif 
....................  
.................... //Keypad connection:   (for example column 0 is B2) 
.................... //                Bx: 
....................  
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad 
.................... #define COL0 (1 << 2) 
.................... #define COL1 (1 << 3) 
.................... #define COL2 (1 << 6) 
....................  
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 7) 
.................... #define ROW2 (1 << 1) 
.................... #define ROW3 (1 << 5) 
....................  
.................... #else ////////////////////////////////////////////////// For the black keypad 
.................... #define COL0 (1 << 5) 
.................... #define COL1 (1 << 6) 
.................... #define COL2 (1 << 7) 
....................  
.................... #define ROW0 (1 << 1) 
.................... #define ROW1 (1 << 2) 
.................... #define ROW2 (1 << 3) 
.................... #define ROW3 (1 << 4) 
....................  
.................... #endif 
....................  
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3) 
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][3] = {{'1','2','3'}, 
....................                          {'4','5','6'}, 
....................                          {'7','8','9'}, 
....................                          {'*','0','#'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
....................  
....................  
.................... void kbd_init() { 
*
00DA:  BCF    0A.3
00DB:  BCF    0A.4
00DC:  GOTO   2AA (RETURN)
.................... } 
....................  
.................... char kbd_getc( ) { 
....................    static BYTE kbd_call_count; 
*
029B:  BCF    03.5
029C:  CLRF   20
....................    static int1 kbd_down; 
029D:  BCF    21.0
....................    static char last_key; 
029E:  CLRF   22
....................    static BYTE col; 
029F:  CLRF   23
....................  
....................    BYTE kchar; 
....................    BYTE row; 
....................  
....................    kchar='\0'; 
*
0166:  CLRF   32
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
0167:  INCF   20,F
0168:  MOVF   20,W
0169:  SUBLW  21
016A:  BTFSC  03.0
016B:  GOTO   1E7
....................        switch (col) { 
016C:  MOVF   23,W
016D:  BTFSC  03.2
016E:  GOTO   176
016F:  XORLW  01
0170:  BTFSC  03.2
0171:  GOTO   17C
0172:  XORLW  03
0173:  BTFSC  03.2
0174:  GOTO   182
0175:  GOTO   187
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0); 
0176:  MOVLW  DE
0177:  BSF    03.5
0178:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS; 
0179:  BCF    03.5
017A:  MOVWF  06
....................                     break; 
017B:  GOTO   187
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1); 
017C:  MOVLW  BE
017D:  BSF    03.5
017E:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS; 
017F:  BCF    03.5
0180:  MOVWF  06
....................                     break; 
0181:  GOTO   187
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2); 
0182:  MOVLW  7E
0183:  BSF    03.5
0184:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS; 
0185:  BCF    03.5
0186:  MOVWF  06
....................                     break; 
....................        } 
....................  
....................        if(kbd_down) { 
0187:  BTFSS  21.0
0188:  GOTO   193
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) { 
0189:  MOVF   06,W
018A:  ANDLW  1E
018B:  SUBLW  1E
018C:  BTFSS  03.2
018D:  GOTO   192
....................            kbd_down=FALSE; 
018E:  BCF    21.0
....................            kchar=last_key; 
018F:  MOVF   22,W
0190:  MOVWF  32
....................            last_key='\0'; 
0191:  CLRF   22
....................          } 
....................        } else { 
0192:  GOTO   1E6
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) { 
0193:  MOVF   06,W
0194:  ANDLW  1E
0195:  SUBLW  1E
0196:  BTFSC  03.2
0197:  GOTO   1E1
....................              if((kbd & ROW0)==0) 
0198:  MOVF   06,W
0199:  ANDLW  02
019A:  BTFSS  03.2
019B:  GOTO   19E
....................                row=0; 
019C:  CLRF   33
019D:  GOTO   1B2
....................              else if((kbd & ROW1)==0) 
019E:  MOVF   06,W
019F:  ANDLW  04
01A0:  BTFSS  03.2
01A1:  GOTO   1A5
....................                row=1; 
01A2:  MOVLW  01
01A3:  MOVWF  33
01A4:  GOTO   1B2
....................              else if((kbd & ROW2)==0) 
01A5:  MOVF   06,W
01A6:  ANDLW  08
01A7:  BTFSS  03.2
01A8:  GOTO   1AC
....................                row=2; 
01A9:  MOVLW  02
01AA:  MOVWF  33
01AB:  GOTO   1B2
....................              else if((kbd & ROW3)==0) 
01AC:  MOVF   06,W
01AD:  ANDLW  10
01AE:  BTFSS  03.2
01AF:  GOTO   1B2
....................                row=3; 
01B0:  MOVLW  03
01B1:  MOVWF  33
....................              last_key =KEYS[row][col]; 
01B2:  MOVF   33,W
01B3:  MOVWF  34
01B4:  MOVLW  03
01B5:  MOVWF  35
*
01DA:  MOVF   23,W
01DB:  ADDWF  78,W
01DC:  CALL   00C
01DD:  MOVWF  78
01DE:  MOVWF  22
....................              kbd_down = TRUE; 
01DF:  BSF    21.0
....................           } else { 
01E0:  GOTO   1E6
....................              ++col; 
01E1:  INCF   23,F
....................              if(col==3) 
01E2:  MOVF   23,W
01E3:  SUBLW  03
01E4:  BTFSC  03.2
....................                col=0; 
01E5:  CLRF   23
....................           } 
....................        } 
....................       kbd_call_count=0; 
01E6:  CLRF   20
....................    } 
....................   set_tris_kbd(ALL_PINS); 
01E7:  MOVLW  FE
01E8:  BSF    03.5
01E9:  MOVWF  06
....................   return(kchar); 
01EA:  BCF    03.5
01EB:  MOVF   32,W
01EC:  MOVWF  78
01ED:  BCF    0A.3
01EE:  BCF    0A.4
01EF:  GOTO   2BA (RETURN)
.................... } 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
02A0:  CLRF   24
02A1:  CLRF   25
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //#rom 0x2100={'7','2','3'} 
....................  
.................... void main(){ 
*
0292:  MOVF   03,W
0293:  ANDLW  1F
0294:  MOVWF  03
0295:  BSF    03.5
0296:  BSF    1F.0
0297:  BSF    1F.1
0298:  BSF    1F.2
0299:  BCF    1F.3
029A:  BCF    03.7
....................    char k; 
....................    int i; 
....................    char data[3], chave[3]; 
....................  
....................    chave[0] = '7'; chave[1] = '2'; chave[2] = '3'; 
*
02A2:  MOVLW  37
02A3:  MOVWF  2F
02A4:  MOVLW  32
02A5:  MOVWF  30
02A6:  MOVLW  33
02A7:  MOVWF  31
....................  
....................    lcd_init(); 
02A8:  GOTO   0A7
....................    kbd_init(); 
02A9:  GOTO   0DA
....................    port_b_pullups(TRUE); 
02AA:  BSF    03.5
02AB:  BCF    01.7
....................  
....................    while(TRUE){ 
....................       i = 0; 
02AC:  BCF    03.5
02AD:  CLRF   2B
....................       printf(lcd_putc, "\fDigite a tecla 1\n"); 
02AE:  MOVLW  1C
02AF:  BSF    03.6
02B0:  MOVWF  0D
02B1:  MOVLW  00
02B2:  MOVWF  0F
02B3:  BCF    03.6
02B4:  CALL   11B
....................       while(i<=2){ 
02B5:  MOVF   2B,W
02B6:  SUBLW  02
02B7:  BTFSS  03.0
02B8:  GOTO   2DC
....................          k=kbd_getc(); 
02B9:  GOTO   166
02BA:  MOVF   78,W
02BB:  MOVWF  2A
....................          if(k!=0){ 
02BC:  MOVF   2A,F
02BD:  BTFSC  03.2
02BE:  GOTO   2DB
....................             data[i] = k; 
02BF:  MOVLW  2C
02C0:  ADDWF  2B,W
02C1:  MOVWF  04
02C2:  BCF    03.7
02C3:  MOVF   2A,W
02C4:  MOVWF  00
....................             i++; 
02C5:  INCF   2B,F
....................             printf(lcd_putc, "\fDigite a tecla %u\n", i+1); 
02C6:  MOVLW  01
02C7:  ADDWF  2B,W
02C8:  MOVWF  32
02C9:  MOVLW  26
02CA:  BSF    03.6
02CB:  MOVWF  0D
02CC:  MOVLW  00
02CD:  MOVWF  0F
02CE:  BCF    03.0
02CF:  MOVLW  10
02D0:  BCF    03.6
02D1:  MOVWF  33
02D2:  GOTO   1F0
02D3:  MOVF   32,W
02D4:  MOVWF  33
02D5:  MOVLW  1B
02D6:  MOVWF  34
02D7:  GOTO   25B
02D8:  MOVLW  0A
02D9:  MOVWF  38
02DA:  CALL   0EF
....................          } 
02DB:  GOTO   2B5
....................       } 
....................       if(data[0]==chave[0] && data[1]==chave[1]  && data[2]==chave[2] ){ 
02DC:  MOVF   2F,W
02DD:  SUBWF  2C,W
02DE:  BTFSS  03.2
02DF:  GOTO   2FF
02E0:  MOVF   30,W
02E1:  SUBWF  2D,W
02E2:  BTFSS  03.2
02E3:  GOTO   2FF
02E4:  MOVF   31,W
02E5:  SUBWF  2E,W
02E6:  BTFSS  03.2
02E7:  GOTO   2FF
....................          printf(lcd_putc, "\fPorta aberta!"); 
02E8:  MOVLW  30
02E9:  BSF    03.6
02EA:  MOVWF  0D
02EB:  MOVLW  00
02EC:  MOVWF  0F
02ED:  BCF    03.6
02EE:  CALL   11B
....................          output_high(PIN_A0); 
02EF:  BSF    03.5
02F0:  BCF    05.0
02F1:  BCF    03.5
02F2:  BSF    05.0
....................          delay_ms(500); 
02F3:  MOVLW  02
02F4:  MOVWF  32
02F5:  MOVLW  FA
02F6:  MOVWF  39
02F7:  CALL   040
02F8:  DECFSZ 32,F
02F9:  GOTO   2F5
....................          output_low(PIN_A0); 
02FA:  BSF    03.5
02FB:  BCF    05.0
02FC:  BCF    03.5
02FD:  BCF    05.0
....................       }else{ 
02FE:  GOTO   30D
....................          printf(lcd_putc, "\fSenha errada!"); 
02FF:  MOVLW  38
0300:  BSF    03.6
0301:  MOVWF  0D
0302:  MOVLW  00
0303:  MOVWF  0F
0304:  BCF    03.6
0305:  CALL   11B
....................          delay_ms(1000); 
0306:  MOVLW  04
0307:  MOVWF  32
0308:  MOVLW  FA
0309:  MOVWF  39
030A:  CALL   040
030B:  DECFSZ 32,F
030C:  GOTO   308
....................       } 
030D:  GOTO   2AD
....................    } 
.................... } 
030E:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
